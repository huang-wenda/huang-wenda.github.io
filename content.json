{"meta":{"title":"NullSky","subtitle":"NullSky","description":"hwd__","author":"Hwd","url":"https://huang-wenda.github.io","root":"/huang-wenda.github.io/"},"pages":[{"title":"","date":"2020-11-17T08:26:12.586Z","updated":"2020-11-17T08:26:12.586Z","comments":true,"path":"404.html","permalink":"https://huang-wenda.github.io/404.html","excerpt":"","text":"title: 404 date: 2018-09-30 17:25:30 type: \"404\" layout: \"404\" description: \"Oops～，我崩溃了！找不到你想要的页面 :(\""},{"title":"about","date":"2020-11-17T07:36:09.000Z","updated":"2020-11-17T07:36:23.627Z","comments":true,"path":"about/index.html","permalink":"https://huang-wenda.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-17T07:34:07.000Z","updated":"2020-11-17T07:35:10.797Z","comments":true,"path":"categories/index.html","permalink":"https://huang-wenda.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-11-17T07:36:36.000Z","updated":"2020-11-17T07:36:48.755Z","comments":true,"path":"contact/index.html","permalink":"https://huang-wenda.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-17T07:37:01.000Z","updated":"2020-11-17T07:37:10.250Z","comments":true,"path":"friends/index.html","permalink":"https://huang-wenda.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-17T07:35:32.000Z","updated":"2020-11-17T07:35:58.959Z","comments":true,"path":"tags/index.html","permalink":"https://huang-wenda.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"刷题笔记_1662","slug":"刷题笔记_1662","date":"2020-12-02T15:53:32.595Z","updated":"2020-12-02T16:36:54.108Z","comments":true,"path":"2020/12/02/shua-ti-bi-ji-1662/","link":"","permalink":"https://huang-wenda.github.io/2020/12/02/shua-ti-bi-ji-1662/","excerpt":"","text":"刷题笔记_1662.检查两个字符串数组是否相等解题思路:首先想到的就是将两个字符串数组运用 StringBuffer 进行拼接再用 equals() 进行比较. 注意: 题目下方的提示,无需考虑数组长度为空或长度超过 1000 的情况. 注意: StringBuffer 不可直接使用 equals() 进行比较,需要使用 toString() String 类中的 equals() 是经过重写的,可以比较两个字符串的内容; 而 StringBuffer 的 equals() 没有进行重写; 实际上调用的是 Object 类的 equals() 也就是直接使用 == 进行比较; 所以会出现值相等而返回 false 的情况白白浪费2次提交 //String类中重写后的equals方法: public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 解题: class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { int length1 = word1.length; int length2 = word2.length; StringBuffer sb1 = new StringBuffer(); StringBuffer sb2 = new StringBuffer(); if(length1 >= 1 &amp;&amp; length2 >= 1 &amp;&amp; length1 &lt;= 1000 &amp;&amp; length2 &lt;= 1000){ for(int i =0;i&lt;length1;i++){ sb1.append(word1[i]); }; for(int j =0;j&lt;length1;j++){ sb2.append(word1[j]); } if(sb1.toString().equals(sb2.toString())){ return true; }else{ return false; } }else{ return false; } } } 过于繁琐,进行简化: class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { StringBuffer sb1 = new StringBuffer(); StringBuffer sb2 = new StringBuffer(); for(String w1 : word1){ sb1.append(w1); }; for(String w2 : word2){ sb2.append(w2); }; return sb1.toString().equals(sb2.toString()); } } 参考解题答案1: //使用join方法 class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { return String.join(\"\", word1).toString().equals(String.join(\"\", word2)); } } 参考解题答案2: //使用流 class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { return Stream.of(word1).reduce(String::concat).orElse(null) .equals(Stream.of(word2).reduce(String::concat).orElse(null)); } } 总结 本题目简直白送相对简单,但是解题过程中仍反应出一些问题:1.审题不够仔细,体现在:题目已明确指出 word1 和 word2 长度均为[1,1000]却依然做了非空以及长度判断(该部分没有体现在上方代码中,但永远留在了提交记录里).2.思路不够清晰,在决定思路后不能流畅的将想法落实于代码,编码过程中多次出现变量名错误等脑瘫问题.3.对流的运用还需要加强.jdk都15了,8还没玩明白,这河里吗???","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://huang-wenda.github.io/tags/leetcode/"}],"author":"HWD"}],"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://huang-wenda.github.io/tags/leetcode/"}]}