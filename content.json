{"meta":{"title":"NullSky","subtitle":"NullSky","description":"hwd__","author":"Hwd","url":"https://huang-wenda.github.io","root":"/huang-wenda.github.io/"},"pages":[{"title":"","date":"2020-11-17T08:26:12.586Z","updated":"2020-11-17T08:26:12.586Z","comments":true,"path":"404.html","permalink":"https://huang-wenda.github.io/404.html","excerpt":"","text":"title: 404 date: 2018-09-30 17:25:30 type: \"404\" layout: \"404\" description: \"Oops～，我崩溃了！找不到你想要的页面 :(\""},{"title":"about","date":"2020-11-17T07:36:09.000Z","updated":"2020-11-17T07:36:23.627Z","comments":true,"path":"about/index.html","permalink":"https://huang-wenda.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-17T07:34:07.000Z","updated":"2020-11-17T07:35:10.797Z","comments":true,"path":"categories/index.html","permalink":"https://huang-wenda.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-11-17T07:36:36.000Z","updated":"2020-11-17T07:36:48.755Z","comments":true,"path":"contact/index.html","permalink":"https://huang-wenda.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-17T07:37:01.000Z","updated":"2020-11-17T07:37:10.250Z","comments":true,"path":"friends/index.html","permalink":"https://huang-wenda.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-17T07:35:32.000Z","updated":"2020-11-17T07:35:58.959Z","comments":true,"path":"tags/index.html","permalink":"https://huang-wenda.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-03T02:44:19.537Z","updated":"2020-12-03T02:44:19.537Z","comments":true,"path":"galleries/index.html","permalink":"https://huang-wenda.github.io/galleries/index.html","excerpt":"","text":""}],"posts":[{"title":"刷题笔记_888","slug":"刷题笔记_888","date":"2020-12-04T07:00:00.000Z","updated":"2020-12-04T10:07:42.239Z","comments":true,"path":"2020/12/04/shua-ti-bi-ji-888/","link":"","permalink":"https://huang-wenda.github.io/2020/12/04/shua-ti-bi-ji-888/","excerpt":"","text":"刷题笔记_888.公平的糖果交换解题思路:首先关注点在糖果大小和数量上，题干中 A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。 怎么也想不明白，尤其是示例3非常的具有误导性： //输入：A = [2], B = [1,3] //输出：[2,3] 翻看答案后发现遗漏了很多要点。 注意1: 一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。 注意2: 返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。也就是说返回的数组长度一定为2。且返回一个即可。 翻看答案后： 本题最主要的线索其实是，爱丽丝（以下简称A）交出的糖x加上获得的糖y等于鲍勃（以下简称B）获得的糖x加上交出的糖y 即：假设A的总糖量为sa，B的总糖量为sb，则有：sa-x+y = sb-y+x，即 y = x+（sb-sa）/2 则结果返回的数组就是[x,y] 提交代码(看答案以后): class Solution { public int[] fairCandySwap(int[] A, int[] B) { /*假设爱丽丝的总糖数为sa 包伯的总数为sb * 则 sa-x+y = sb-y+x * 2y = 2x+sb-sa * y = x+(sb-sa)/2 * 只要求出满足上述条件的x,y即可 * */ int sa = 0; int sb = 0; int[] result = new int[2]; for (int x:A){sa+=x;}; for (int x:B){sb+=x;}; int temp = (sb-sa)/2; /*y=x+1*/ for(int y:B){ for (int x:A){ if (y==x+temp){ result[0] = x; result[1] = y; return result; } } } return null; } } 提交结果: ​ 执行用时：273 ms, 在所有 Java 提交中击败了26.03%的用户 ​ 内存消耗：40.1 MB, 在所有 Java 提交中击败了75.50%的用户 ​ [时间复杂度过高] 官方解答:使用Set来存放B可以大幅减少时间，测试提交时耗时仅9ms！！ class Solution { public int[] fairCandySwap(int[] A, int[] B) { int sa = 0, sb = 0; // sum of A, B respectively for (int x: A) sa += x; for (int x: B) sb += x; int delta = (sb - sa) / 2; // If Alice gives x, she expects to receive x + delta Set&lt;Integer> setB = new HashSet(); for (int x: B) setB.add(x); for (int x: A) if (setB.contains(x + delta)) return new int[]{x, x + delta}; throw null; } } 参考答案2：（思路奇特，时间，空间使用均超过官方解答） class Solution { public int[] fairCandySwap(int[] A, int[] B) { int diff = 0; //题目中给出最大长度&lt;=100000 boolean[] flags = new boolean[100001]; //计算差值 //方法独特 for (int a:A){ diff -= a; } //分别进行+和-就可以直接得到diff的值 for(int b:B){ diff +=b; flags[b] = true; } //已知关系 b = a+diff/2 diff /=2; for (int a:A){ int numB = a+diff; if (numB>0 &amp;&amp; numB&lt;100001 &amp;&amp; flags[numB]){ return new int[]{a,numB}; } } throw null; } } 总结 本题难点： 1.要找到二人交换糖果过程中产生的数量变化关系。2.找到关系式后难度大幅下降，但是时间、空间的利用也需要注意。直接遍历两个数组将耗费大量的时间，官方给出的方法利用Set的特性待考证来降低时间复杂度。答案二待研究解法更优。值得学习。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://huang-wenda.github.io/tags/leetcode/"}],"author":"HWD"},{"title":"刷题笔记_1662","slug":"刷题笔记_1662","date":"2020-12-02T15:53:32.595Z","updated":"2020-12-03T03:10:27.176Z","comments":true,"path":"2020/12/02/shua-ti-bi-ji-1662/","link":"","permalink":"https://huang-wenda.github.io/2020/12/02/shua-ti-bi-ji-1662/","excerpt":"","text":"刷题笔记_1662.检查两个字符串数组是否相等解题思路:首先想到的就是将两个字符串数组运用 StringBuffer 进行拼接再用 equals() 进行比较. 注意: 题目下方的提示,无需考虑数组长度为空或长度超过 1000 的情况. 注意: StringBuffer 不可直接使用 equals() 进行比较,需要使用 toString() String 类中的 equals() 是经过重写的,可以比较两个字符串的内容; 而 StringBuffer 的 equals() 没有进行重写; 实际上调用的是 Object 类的 equals() 也就是直接使用 == 进行比较; 所以会出现值相等而返回 false 的情况白白浪费2次提交 //String类中重写后的equals方法: public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } 解题: class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { int length1 = word1.length; int length2 = word2.length; StringBuffer sb1 = new StringBuffer(); StringBuffer sb2 = new StringBuffer(); if(length1 >= 1 &amp;&amp; length2 >= 1 &amp;&amp; length1 &lt;= 1000 &amp;&amp; length2 &lt;= 1000){ for(int i =0;i&lt;length1;i++){ sb1.append(word1[i]); }; for(int j =0;j&lt;length1;j++){ sb2.append(word1[j]); } if(sb1.toString().equals(sb2.toString())){ return true; }else{ return false; } }else{ return false; } } } 过于繁琐,进行简化: class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { StringBuffer sb1 = new StringBuffer(); StringBuffer sb2 = new StringBuffer(); for(String w1 : word1){ sb1.append(w1); }; for(String w2 : word2){ sb2.append(w2); }; return sb1.toString().equals(sb2.toString()); } } 参考解题答案1: //使用join方法 class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { return String.join(\"\", word1).toString().equals(String.join(\"\", word2)); } } 参考解题答案2: //使用流 class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { return Stream.of(word1).reduce(String::concat).orElse(null) .equals(Stream.of(word2).reduce(String::concat).orElse(null)); } } 总结 本题目简直白送相对简单,但是解题过程中仍反应出一些问题:1.审题不够仔细,体现在:题目已明确指出 word1 和 word2 长度均为[1,1000]却依然做了非空以及长度判断(该部分没有体现在上方代码中,但永远留在了提交记录里).2.思路不够清晰,在决定思路后不能流畅的将想法落实于代码,编码过程中多次出现变量名错误等脑瘫问题.3.对流的运用还需要加强.jdk都15了,8还没玩明白,这河里吗???","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://huang-wenda.github.io/tags/leetcode/"}],"author":"HWD"}],"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://huang-wenda.github.io/tags/leetcode/"}]}